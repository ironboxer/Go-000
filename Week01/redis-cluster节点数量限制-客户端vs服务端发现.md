#### redis-cluster 中的节点数量限制 && 服务发现中的 服务发现中的 客户端发现 vs 服务端发现

Redis Cluster是redis分布式集群解决大容量存储的方案，但是这个方案中规定了集群中节点的数量限制:不超过1000个节点。

原因就是**实例间的通信开销会随着实例规模的增加而增大**,在集群超过一定规模时(1000个节点)，集群吞吐量反而会下降。

> 类似于超算，不是简单的堆芯片就可以提升性能。当芯片的数量增多到一定的数量，芯片之间通信的开销会变的巨大。
> 此时单个芯片的算力不再是主要矛盾，通信变成了主要矛盾。


如果放弃Redis-Cluster这种方案，采用Codis这种方式，效果会如何？

Codis会把每个节点的槽位信息保存在zookeeper等分布式协调中心中, 每个Redis实例只保存自己槽位的相关信息, Redis实例之间无感知, 不交流，可以"无限扩展"。客户端的请求会先经过codis-proxy，然后根据槽位信息做路由转发。


redis-cluster vs codis  && 客户端发现 vs 服务端发现


redis-cluster和codis这两种技术路线和服务发现中的客户端发现/服务端发现有点相似。
只要codis中的codis-proxy和下游存储的redis实例之间是1:n的关系，总是存在单点问题，添加更加的codis-proxy只能缓解，无法彻底解决。服务端发现也有类似的问题，只要客户端和服务端不是直连，而是通过API Getway(如nginx)做了一次转发，那么API Getay 就是一个单点。解决方案也都是类似的，尽可能让这个做转发的代理的业务变的简单，而且无状态。

redis-cluster中的各个redis节点随着节点数量的增加，通信开销会陡增。即便像维护心跳同步这样最基础的操作，都有可能形成"网络风暴"，解决方案就是每次选取部分节点做同步。客户端与服务端直连也会面临同样的问题，每个客户端节点都需要维护与服务端节点的连接，定时做心跳检测，一旦客户端节点变多，服务端压力也会变的很大。解决方案就是采用子集算法，客户端从服务端列表中选取一个子集来连接，从而减小服务端节点因连接过多造成的压力。在这个问题上，redis-cluster的问题更严重，因为redis-cluster是DB, 必须要保证数据的一致性，即便是最终一致性，所以心跳检测的周期不能太长，而且需要做额外的检查。


> redis-cluster中个节点间同步用的gossip协议也是一种子集算法的体现, 每次只选取部分节点做同步，已同步的节点不再同步，B接受到A发送的消息后不能再返送到A，都是尽可能地减小数据同步带来的网络通信开销。
